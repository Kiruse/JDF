# JDF Grammar Subsystem
The Grammar which can be described with JDF builds upon automata theory. Most parser generators use recursive descent, but JDF uses deterministic conversion to produce an equivalent DFA for any given NFA.

Built atop the *automaton* subsystem is the `Matcher` subsystem, which abstracts the creation & linking of `SubGraph`s - which are simply NFAs.

Built atop the *Matcher* subsystem is the `match` subsystem, which is a tagged template function producing `Matcher`s through a [BNF](https://en.wikipedia.org/wiki/Backusâ€“Naur_form)-like language.

Also built atop the *Matcher* subsystem is the `Language` subsystem, which associates `Matcher`s with the corresponding rules of your language and intermingles captures into the `SubGraph`.

Finally, the `ProgrammingLanguage` specialization is designed to simplify & streamline the development of programming languages.

## Non-Deterministic vs Deterministic Parsers
Recursive descent parsers are typically implemented to "try" paths, and upon failure rewind to "try" another path - until all paths have been exhausted. This is when they fail. Typically, they will implement some sort of priority ordering, e.g. if two rules match a specific input, the rule matching more input wins.

Deterministic parsers like those generated by JDF perform additional computations on the rules you provide, allowing them to merge alternate paths where they match the same input sequence, until they don't. This means that, if two rules consume the exact same input, the automaton will successfully process both rules simultaneously, and produce corresponding information.

Unlike recursive descent parsers which, upon failure, supply you error information akin to "exhausted alternatives, expected x y z", JDF parsers will tell you exactly which input they expected next, and which rules these expectations belong to.

Finally, the advantage of using an actual graph to parse & process input sequences is the ability to visualize them: you can iterate step through step through the graph as it parses your input and observe its transitions and state changes. This provides you with debugging capabilities other parser generators lack.

## State of this Subsystem
| Feature                  | Progress |
| ------------------------ | -------- |
| Deterministic Conversion | 0%       |
| `Matcher`s               | 80%      |
| `match`                  | 80%      |
| `Language`               | 0%       |
