import { VisitorASTNodes, AnyVisitor, ASTNodeBase, OptionsASTNode, RuleASTNode } from '../types';

type Fn<Args extends any[] = any[], R = any> = (...args: Args) => R;
type Defined<T> = T extends undefined ? never : T;
type Compose<F extends Fn, G extends Fn> = (...args: Parameters<F>) => ReturnType<G>;

export type TransformMap<V extends AnyVisitor = any> = {
  [K in keyof V]?: (node: ReturnType<V[K]>) => any;
}

type VisitorHelper<V extends AnyVisitor | BaseTransformer> =
  V extends BaseTransformer
  ? TransformVisitorFromBase<V>
  : V extends AnyVisitor
  ? V
  : never;

type Transform<V extends AnyVisitor, T extends TransformMap<V>, Type extends string> =
  Type extends keyof T
  ? ReturnType<Defined<T[Type]>>
  : Type extends keyof V
  ? GenericTransform<ReturnType<V[Type]>, V, T>
  : never;
type GenericTransform<N extends ASTNodeBase, V extends AnyVisitor, T extends TransformMap<V>> =
  N extends OptionsASTNode
  ? (
    & Omit<N, 'children' | 'option'>
    & {
        option: Transform<V, T, N['option']['type']>;
        children: [Transform<V, T, N['option']['type']>];
      }
    )
  : N extends RuleASTNode
  ? (
      & Omit<N, 'children' | 'rules'>
      & { children: Transform<V, T, N['children'][number]['type']>[] }
      & (
          N extends { rules: any }
          ? { rules: { [K in keyof N['rules']]: Transform<V, T, N['rules'][K][number]['type']>[] } }
          : {}
        )
    )
  : never;

export type TFVisitor<T> = T extends BaseTransformer<infer V, any> ? V : never;
type TransformVisitor<V extends AnyVisitor, T extends TransformMap<V>> =
  & { [K in Exclude<keyof V, keyof T>]: (...args: Parameters<V[K]>) => Transform<V, T, ReturnType<V[K]>['type']> }
  & { [K in keyof T & keyof V]: Compose<V[K], Defined<T[K]>> }
  & { [K in Exclude<keyof T, keyof V>]: Defined<T[K]> };
export type TransformVisitorFromBase<T> = T extends BaseTransformer<infer V, infer T> ? TransformVisitor<V, T> : never;

/** `BaseTransformer`s are the standard transformer for 1st Gen ASTs generated by LDTK. It can be
 * used with any AST that somewhat resembles the 1st Gen ASTs, i.e. adheres to these types:
 * 
 * ```typescript
 * type ASTBaseNode = RuleASTNode | OptionsASTNode;
 * type RuleASTNode = {
 *   type: string;
 *   family: 'rule';
 *   rules: Record<string, ASTNodeBase>;
 *   children: ASTNodeBase[] | never[];
 * }
 * type OptionsASTNode = {
 *   type: string;
 *   family: 'options';
 *   option: ASTNodeBase;
 *   children: [ASTNodeBase];
 * }
 * ```
 */
export class BaseTransformer<V extends AnyVisitor = any, T extends TransformMap<V> = any> {
  constructor(private transformer: T) {}
  
  transform<N extends VisitorASTNodes<V>>(node: N): Transform<V, T, N['type']> {
    return this._inner_transform(node, new Map());
  }
  
  protected _inner_transform(node: any, visited: Map<ASTNodeBase, ASTNodeBase>): any {
    if (node.type in this.transformer) {
      return this.transformer[node.type]!(node);
    } else {
      return this._basic_transform(node, visited);
    }
  }
  
  protected _basic_transform(node: ASTNodeBase, visited: Map<ASTNodeBase, ASTNodeBase>): any {
    if (visited.has(node)) return visited.get(node);
    
    const tf = clone(node);
    visited.set(node, tf);
    
    if (tf.family === 'options') {
      tf.option = this._inner_transform(tf.option, visited);
      tf.children = [tf.option];
    }
    else {
      if (tf.rules) {
        tf.rules = Object.fromEntries(
          Object.entries(tf.rules).map(([key, children]) =>
            [key, children.map(child => this._inner_transform(child as any, visited))]
          )
        );
        tf.children = Object.values(tf.rules).reduce((prev: any[], curr) => prev.concat(curr), [] as ASTNodeBase[]);
      }
    }
    return tf;
  }
  
  /** Helper for defining a transformer based on the types of `visit`. */
  static from<V extends AnyVisitor | BaseTransformer, T extends TransformMap<VisitorHelper<V>>>(visit: V, transformer: T) {
    return new BaseTransformer<
      V extends BaseTransformer ? TransformVisitorFromBase<V> : V,
      T
    >(transformer);
  }
}

export const createTransformer = <V extends AnyVisitor | BaseTransformer, T extends TransformMap<VisitorHelper<V>>>(visit: V, transformer: T) => transformer;

function clone<T>(source: T): T {
  const result = Object.create(Object.getPrototypeOf(source));
  Object.defineProperties(result, Object.getOwnPropertyDescriptors(source));
  return result;
}
