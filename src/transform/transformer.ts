import { ASTNodes, AnyVisitor, ASTNodeBase } from './types';

type Defined<T> = T extends undefined ? never : T;

export type TransformMap<V extends AnyVisitor = any> = {
  [K in keyof V]?: (node: ReturnType<V[K]>) => any;
}

type TransformResult<V extends AnyVisitor, T extends TransformMap<V>, Type extends keyof V> =
  Type extends keyof T
  ? ReturnType<Defined<T[Type]>>
  : Transform<V, T, ReturnType<V[Type]>>;
type Transform<V extends AnyVisitor, T extends TransformMap<V>, N extends ASTNodeBase> =
  N['type'] extends keyof T
  ? ReturnType<Defined<T[N['type']]>>
  : Omit<N, 'children' | 'rules'> & {
      children: Transform<V, T, N['children'][number]>[];
    } & (
      N extends { rules: any }
      ? { rules: { [K in keyof N['rules']]: Transform<V, T, N['rules'][K]> } }
      : {}
    );

/** `BaseTransformer`s are the standard transformer for 1st Gen ASTs generated by LDTK. It can be
 * used with any AST that somewhat resembles the 1st Gen ASTs, i.e. adheres to these types:
 * 
 * ```typescript
 * type ASTBaseNode = RuleASTNode | OptionsASTNode;
 * type RuleASTNode = {
 *   type: string;
 *   family: 'rule';
 *   rules: Record<string, ASTNodeBase>;
 *   children: ASTNodeBase[] | never[];
 * }
 * type OptionsASTNode = {
 *   type: string;
 *   family: 'options';
 *   option: ASTNodeBase;
 *   children: [ASTNodeBase];
 * }
 * ```
 */
export class BaseTransformer<V extends AnyVisitor, T extends TransformMap<V>> {
  constructor(private transformer: T) {}
  
  transform<N extends ASTNodes<V>>(node: N): TransformResult<V, T, N['type']> {
    return this._inner_transform(node, new Set());
  }
  
  protected _inner_transform(node: any, visited: Set<ASTNodeBase>): any {
    if (node.type in this.transformer) {
      return this.transformer[node.type]!(node);
    } else {
      return this._basic_transform(node, visited);
    }
  }
  
  protected _basic_transform(node: ASTNodeBase, visited: Set<ASTNodeBase>): any {
    if (visited.has(node)) return node;
    visited.add(node);
    
    const transformed = clone(node);
    if (transformed.family === 'options') {
      transformed.option = this._inner_transform(transformed.option, visited);
      transformed.children = [transformed.option];
    }
    else {
      transformed.children = node.children.map((child: any) => this._inner_transform(child, visited));
      if ('rules' in transformed) {
        transformed.rules = Object.fromEntries(
          Object.entries(transformed.rules).map(([key, value]) => [key, this._inner_transform(value as any, visited)])
        );
      }
    }
    return transformed;
  }
  
  /** Helper for defining a transformer based on the types of `visit`. */
  static from<V extends AnyVisitor, T extends TransformMap<V>>(visit: V, transformer: T) {
    return new BaseTransformer(transformer);
  }
}

function clone(source: any): any {
  const result = Object.create(Object.getPrototypeOf(source));
  Object.defineProperties(result, Object.getOwnPropertyDescriptors(source));
  return result;
}
